name: Secret Scanning

# Trigger this workflow on:
# - Pull requests targeting main or dev branches
# - Direct pushes to main or dev branches  
# - Manual workflow dispatch from GitHub UI
on:
  pull_request:
    branches: [ "main", "dev" ]
  push:
    branches: [ "main", "dev" ]
  workflow_dispatch:

jobs:
  secret-scan:
    runs-on: ubuntu-latest
    timeout-minutes: 30  # Prevent long-running scans on large repos
    
    # Required permissions for this workflow
    permissions:
      contents: read          # Read repository contents
      pull-requests: write    # Comment on pull requests
      security-events: write  # Upload SARIF reports to Security tab

    steps:
      # Step 1: Check out the repository with full git history
      # Full history is needed to scan all commits, not just the latest
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Step 2: Run gitleaks - industry-standard secret scanning tool
      # Uses continue-on-error so custom patterns can still run if gitleaks fails
      - name: Run gitleaks scan
        id: gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}  # Optional, for enterprise features
        continue-on-error: true

      # Step 3: Upload gitleaks results to GitHub Security tab
      # This integrates findings into GitHub's native security features
      - name: Upload gitleaks SARIF report
        if: always()  # Run even if gitleaks failed
        uses: github/codeql-action/upload-sarif@v3
        continue-on-error: true  # Don't fail workflow if SARIF upload fails
        with:
          sarif_file: results.sarif
          category: gitleaks

      # Step 4: Archive gitleaks report as downloadable artifact
      # Only uploads if results.sarif exists (checked via hashFiles)
      - name: Upload gitleaks artifacts
        if: always() && hashFiles('results.sarif') != ''
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-report-${{ github.run_id }}  # Unique name per run
          path: results.sarif
          retention-days: 30  # Keep for 30 days for audit purposes

      # Step 5: Custom pattern scanning for additional secret detection
      # Complements gitleaks with organization-specific patterns
      - name: Custom pattern scan
        id: custom-scan
        if: always()  # Run even if gitleaks failed
        shell: bash
        run: |
          # Exit on error, undefined variables, and pipe failures
          set -euo pipefail
          
          echo ""
          echo "ğŸ” Running additional custom pattern checks..."
          
          # Define file patterns to exclude from scanning
          # Excludes: docs, tests, examples, minified files, lock files, node_modules
          EXCLUSIONS=':!*.md :!docs/* :!*.lock :!*test* :!*.example* :!*.template* :!*.sample* :!.git/* :!*.min.js :!*.min.css :!package-lock.json :!yarn.lock :!node_modules/*'
          
          # Set up findings file and temporary working directory
          FINDINGS_FILE="${GITHUB_WORKSPACE}/findings.txt"
          TEMP_DIR="${RUNNER_TEMP}/secret-scan-$$"  # Use $$ (PID) for uniqueness
          mkdir -p "$TEMP_DIR"
          : > "$FINDINGS_FILE"  # Create empty findings file
          
          found=0  # Track if any secrets were found
          declare -A severities  # Associative array to count findings by severity
          
          # Cleanup function - ensures temp files are removed on exit
          cleanup() {
            local exit_code=$?
            rm -rf "$TEMP_DIR"
            # Remove findings file if empty
            if [ -f "$FINDINGS_FILE" ] && [ ! -s "$FINDINGS_FILE" ]; then
              rm -f "$FINDINGS_FILE"
            fi
            return $exit_code
          }
          trap cleanup EXIT  # Register cleanup to run on script exit
          
          # Helper function: Search for a specific secret pattern
          # Args: name, regex_pattern, severity_level, grep_flags
          search_pattern() {
            local name="$1"
            local pattern="$2"
            local severity="${3:-MEDIUM}"  # Default to MEDIUM if not specified
            local flags="${4:--nE}"         # Default to -nE (line numbers, extended regex)
            local temp_file="$TEMP_DIR/$(echo "$name" | tr ' ' '_').txt"
            
            echo "Checking $name..."
            # Run git grep, limit to 100 matches, save to temp file
            # Note: 2>/dev/null suppresses "no matches" messages, not actual errors
            if git grep $flags "$pattern" -- $EXCLUSIONS 2>/dev/null | head -100 > "$temp_file" && [ -s "$temp_file" ]; then
              echo "âš ï¸  $name detected [$severity]"
              echo "=== $name [$severity] ===" >> "$FINDINGS_FILE"
              cat "$temp_file" >> "$FINDINGS_FILE"
              echo "" >> "$FINDINGS_FILE"
              # Increment severity counter
              severities["$severity"]=$((${severities["$severity"]:-0} + 1))
              found=1
            fi
          }
          
          # HIGH SEVERITY PATTERNS
          # These are immediate security risks that can lead to account compromise
          
          # Cloud Provider Credentials
          search_pattern "AWS Access Keys" 'AKIA[0-9A-Z]{16}|ASIA[0-9A-Z]{16}' "HIGH"
          search_pattern "Azure Connection Strings" 'DefaultEndpointsProtocol=https;AccountName=[^;]+;AccountKey=[A-Za-z0-9+/]{88}==' "HIGH"
          search_pattern "Azure Storage Keys" 'AccountKey=[A-Za-z0-9+/]{88}==' "HIGH"
          search_pattern "Google Cloud API Keys" 'AIza[0-9A-Za-z_-]{35}' "HIGH"
          
          # Platform Authentication Tokens
          search_pattern "GitHub Tokens" 'gh[pousr]_[0-9a-zA-Z]{36}|github_pat_[0-9a-zA-Z_]{82}' "HIGH"
          search_pattern "Slack Tokens" 'xox[baprs]-[0-9]{10,13}-[0-9]{10,13}-[0-9a-zA-Z]{24,32}' "HIGH"
          search_pattern "NPM Tokens" 'npm_[A-Za-z0-9]{36}' "HIGH"
          search_pattern "Docker Hub Tokens" 'dckr_pat_[A-Za-z0-9_-]{36}' "HIGH"
          
          # Private Cryptographic Keys (PEM format with header/footer markers)
          search_pattern "Private Keys" '-----BEGIN [A-Z ]+ PRIVATE KEY-----' "HIGH"
          search_pattern "SSH Private Keys" '-----BEGIN (RSA|DSA|EC|OPENSSH) PRIVATE KEY-----' "HIGH"
          
          # MEDIUM SEVERITY PATTERNS
          # These can expose data or services but typically have some protection layers
          
          # Database Connection Strings with embedded credentials
          search_pattern "Database Connection Strings" '(mysql|postgresql|mongodb|redis|mssql)://[^:]+:[^@\s]{4,}@' "MEDIUM" "-nEi"
          search_pattern "SQL Server Credentials" 'Server=[^;]+;.*Password=[^;]{4,}' "MEDIUM" "-nEi"
          
          # Third-party Service API Keys
          search_pattern "Stripe API Keys" 'sk_live_[0-9a-zA-Z]{24}' "MEDIUM"
          search_pattern "Twilio API Keys" 'SK[0-9a-f]{32}' "MEDIUM"
          search_pattern "SendGrid API Keys" 'SG\.[0-9A-Za-z_-]{22}\.[0-9A-Za-z_-]{43}' "MEDIUM"
          
          # JWT Tokens (may be expired or for non-production)
          search_pattern "JWT Tokens" 'eyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}' "MEDIUM"
          
          # LOW SEVERITY PATTERNS
          # Generic patterns that may produce false positives but worth reviewing
          
          # Generic hardcoded credentials with placeholder filtering
          echo "Checking hardcoded credentials..."
          creds_temp="$TEMP_DIR/creds.txt"
          # Search for credential assignments, then filter out common placeholders
          # Requires minimum 12 characters to reduce false positives from validation examples
          if git grep -nEi "(password|passwd|pwd|secret|api[_-]?key|apikey|access[_-]?key|auth[_-]?token|bearer)\s*[=:]\s*[\"'][^\"'\s<>]{12,}[\"']" -- $EXCLUSIONS 2>/dev/null | \
             grep -viE '(YOUR|CHANGE|REPLACE|EXAMPLE|DUMMY|TEST|PLACEHOLDER|TODO|FIXME|XXX|REDACTED|<[^>]+>|\$\{|\{\{|minimum|maximum|validation)' | \
             head -100 > "$creds_temp" && [ -s "$creds_temp" ]; then
            echo "âš ï¸  Hardcoded credentials detected [LOW]"
            echo "=== Hardcoded Credentials [LOW] ===" >> "$FINDINGS_FILE"
            cat "$creds_temp" >> "$FINDINGS_FILE"
            echo "" >> "$FINDINGS_FILE"
            severities["LOW"]=$((${severities["LOW"]:-0} + 1))
            found=1
          fi
          
          # Base64-encoded secrets (high entropy strings)
          search_pattern "Base64 Encoded Secrets" "(secret|password|key)\s*[=:]\s*[\"'][A-Za-z0-9+/]{40,}={0,2}[\"']" "LOW"
          
          # Generate summary and set outputs
          if [ $found -eq 1 ]; then
            echo ""
            echo "âŒ Potential secrets detected in code!"
            echo ""
            echo "ğŸ“Š Severity Summary:"
            [ "${severities[HIGH]:-0}" -gt 0 ] && echo "   ğŸ”´ HIGH:   ${severities[HIGH]} type(s)"
            [ "${severities[MEDIUM]:-0}" -gt 0 ] && echo "   ğŸŸ¡ MEDIUM: ${severities[MEDIUM]} type(s)"
            [ "${severities[LOW]:-0}" -gt 0 ] && echo "   ğŸ”µ LOW:    ${severities[LOW]} type(s)"
            echo ""
            echo "ğŸ“‹ Detailed findings saved to: findings.txt"
            echo "   (First 100 matches per pattern shown)"
            echo ""
            echo "ğŸ“‹ Required Actions:"
            echo "  1. Remove ALL secrets from the code immediately"
            echo "  2. If committed to main/dev, ROTATE the credentials"
            echo "  3. Use secure alternatives:"
            echo "     â€¢ GitHub Secrets for CI/CD workflows"
            echo "     â€¢ Azure Key Vault for application secrets"
            echo "     â€¢ Environment variables from secure sources"
            echo "  4. For config examples, use placeholder patterns:"
            echo "     password: '<YOUR_PASSWORD_HERE>'"
            echo "     api_key: '\${API_KEY}' or '{{API_KEY}}'"
            echo ""
            # Set step outputs for use in subsequent steps
            {
              echo "custom_scan_status=failed"
              echo "findings_file=$FINDINGS_FILE"
              echo "high_severity=${severities[HIGH]:-0}"
              echo "medium_severity=${severities[MEDIUM]:-0}"
              echo "low_severity=${severities[LOW]:-0}"
            } >> "$GITHUB_OUTPUT"
            exit 1  # Fail the step
          else
            echo "âœ… No secrets detected by custom patterns"
            {
              echo "custom_scan_status=passed"
              echo "high_severity=0"
              echo "medium_severity=0"
              echo "low_severity=0"
            } >> "$GITHUB_OUTPUT"
            rm -f "$FINDINGS_FILE"
          fi

      # Step 6: Upload custom scan findings as artifact
      # Only uploads if findings.txt exists (secrets were found)
      - name: Upload custom scan findings
        if: always() && hashFiles('findings.txt') != ''
        uses: actions/upload-artifact@v4
        with:
          name: custom-scan-findings-${{ github.run_id }}
          path: findings.txt
          retention-days: 30

      # Step 7: Generate overall scan summary
      # Combines results from both gitleaks and custom scans
      - name: Scan summary
        if: always()  # Always run to provide summary
        run: |
          set +e  # Don't exit immediately on error (we want to show full summary)
          
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "   ğŸ” Secret Scanning Summary"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          # Get outcomes from previous steps
          gitleaks_status="${{ steps.gitleaks.outcome }}"
          custom_status="${{ steps.custom-scan.outcome }}"
          high_severity="${{ steps.custom-scan.outputs.high_severity }}"
          
          overall_fail=0  # Track overall workflow status
          
          # Display gitleaks result
          if [ "$gitleaks_status" == "success" ]; then
            echo "âœ… Gitleaks scan: PASSED"
          else
            echo "âŒ Gitleaks scan: FAILED"
            overall_fail=1
          fi
          
          # Display custom scan result
          if [ "$custom_status" == "success" ]; then
            echo "âœ… Custom patterns: PASSED"
          else
            echo "âŒ Custom patterns: FAILED"
            overall_fail=1
            # Highlight high severity findings
            if [ -n "$high_severity" ] && [ "$high_severity" != "0" ]; then
              echo "   âš ï¸  Includes $high_severity HIGH severity finding(s)"
            fi
          fi
          
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          # Determine final status
          if [ $overall_fail -eq 1 ]; then
            echo ""
            echo "ğŸš¨ Secret scanning detected potential issues!"
            echo "   ğŸ“¥ Download artifacts for detailed findings"
            echo "   ğŸ“ Review the logs above for next steps"
            exit 1  # Fail the workflow
          else
            echo ""
            echo "âœ… All secret scans passed successfully"
            echo "   No secrets detected in this commit"
          fi

      # Step 8: Check if we've already commented on this PR
      # Prevents duplicate comments on subsequent workflow runs
      - name: Check for existing comment
        if: failure() && github.event_name == 'pull_request'
        id: find-comment
        uses: peter-evans/find-comment@v3
        with:
          issue-number: ${{ github.event.pull_request.number }}
          comment-author: 'github-actions[bot]'
          body-includes: 'ğŸš¨ Secret Scanning Failed'

      # Step 9: Create or update PR comment with scan results
      # Provides actionable feedback directly on the PR
      - name: Create or update PR comment
        if: failure() && github.event_name == 'pull_request'
        uses: peter-evans/create-or-update-comment@v4
        with:
          comment-id: ${{ steps.find-comment.outputs.comment-id }}  # Update existing if found
          issue-number: ${{ github.event.pull_request.number }}
          edit-mode: replace  # Replace content if updating
          body: |
            ## ğŸš¨ Secret Scanning Failed
            
            Potential secrets were detected in this PR.
            
            **Severity Summary:**
            ${{ steps.custom-scan.outputs.high_severity != '0' && steps.custom-scan.outputs.high_severity != '' && format('- ğŸ”´ HIGH: {0} type(s)', steps.custom-scan.outputs.high_severity) || '' }}
            ${{ steps.custom-scan.outputs.medium_severity != '0' && steps.custom-scan.outputs.medium_severity != '' && format('- ğŸŸ¡ MEDIUM: {0} type(s)', steps.custom-scan.outputs.medium_severity) || '' }}
            ${{ steps.custom-scan.outputs.low_severity != '0' && steps.custom-scan.outputs.low_severity != '' && format('- ğŸ”µ LOW: {0} type(s)', steps.custom-scan.outputs.low_severity) || '' }}
            
            **Action Required:**
            1. ğŸ“¥ Download the `custom-scan-findings-${{ github.run_id }}` artifact from the workflow run
            2. ğŸ” Review all detected secrets
            3. âŒ Remove all secrets from the code
            4. ğŸ”„ If already committed, **rotate the credentials immediately**
            5. âœ… Use GitHub Secrets or Azure Key Vault instead
            
            [ğŸ“Š View Full Details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})